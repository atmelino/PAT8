


    Path = mpath.Path
    path_data = [
        (Path.MOVETO, (1.58, -2.57)),
        (Path.CURVE4, (0.35, -1.1)),
        (Path.CURVE4, (-1.75, 2.0)),
        (Path.CURVE4, (0.375, 2.0)),
        (Path.LINETO, (0.85, 1.15)),
        (Path.CURVE4, (2.2, 3.2)),
        (Path.CURVE4, (3, 0.05)),
        (Path.CURVE4, (2.0, -0.5)),
        (Path.CLOSEPOLY, (1.58, -2.57)),
        ]
    codes, verts = zip(*path_data)
    path = mpath.Path(verts, codes)
    patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)
    ax.add_patch(patch)


    # plot control points and connecting lines
    x, y = zip(*path.vertices[:-1])
    points = ax.plot(x, y, 'go', ms=10)
    line = ax.plot(x, y, '-k')


    #soa = np.array([ [-10000, 0, 0, 1000, 0, 0], [-5100   , 8577 , 0 , 513 , -863 , 0], [487, 9943 , 0 , -49 , -1008, 0]]) 
    #X, Y, Z, U, V, W = zip(*soa)

    # workaround for bug in mpld3:
V1=np.negative(V)    
Q = plt.quiver(X, Y, U, V1)
def add_force(F, x1):
    """Add a vertical force arrow F pixels long at x1 (in data coordinates)."""
    ax.annotate('', xy=(40000,70000), xytext=(0, F), textcoords='offset points', arrowprops=dict(arrowstyle='<|-', color='r'))

    add_force(60000, 4.5)
    add_force(-45, 6.5)
    # ax = fig.add_subplot(111)
    # ax.plot(x,y, 'k', lw=2)
    # ax = plt.axes()
    ax.arrow(10000, 30000, 50000, 10000, head_width=0.05, head_length=0.1, fc='k', ec='k')
    #plt.arrow(10000, 0, 50000, 10000, head_width=1000)


def moonPositionx(t):    
    return 300000

    #dxdt[0] = vx;
    #dxdt[1] = vy;
    #dxdt[2] = vz;
    #dxdt[3] = muorc * x
    #dxdt[4] = muorc * y
    #dxdt[5] = muorc * z
    #dsq = x * x + y * y  # distance squared
    # print dsq
    # dr = math.sqrt(dsq)  # distance
    # print dr
    # force = GM if dsq > 1e-10 else 0.
    # force = GM
    # xdotdot = -force * x / dr
    # ydotdot = -force * y / dr
    # drdt = [xdot, ydot, xdotdot, ydotdot]
    # return drdt

